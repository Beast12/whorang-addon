---
name: Version Management and Auto-Tagging

on:
  push:
    branches:
      - main
    paths:
      - 'whorang/**'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version increment type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      should_version: ${{ steps.changes.outputs.should_version }}
      version_type: ${{ steps.changes.outputs.version_type }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect version increment type
        id: changes
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v2.0.33")
          echo "Latest tag: $LATEST_TAG"
          
          # Get commits since last tag
          COMMITS_SINCE_TAG=$(git rev-list ${LATEST_TAG}..HEAD --count)
          echo "Commits since tag: $COMMITS_SINCE_TAG"
          
          if [ "$COMMITS_SINCE_TAG" -eq 0 ]; then
            echo "No new commits since last tag"
            echo "should_version=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Analyze commit messages to determine version type
          COMMIT_MESSAGES=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" || git log --pretty=format:"%s" -n 5)
          
          # Default to patch
          VERSION_TYPE="patch"
          
          # Check for breaking changes or major features
          if echo "$COMMIT_MESSAGES" | grep -iE "(BREAKING|breaking change|major:|!:)" > /dev/null; then
            VERSION_TYPE="major"
          # Check for new features
          elif echo "$COMMIT_MESSAGES" | grep -iE "(feat:|feature:|add:|new:)" > /dev/null; then
            VERSION_TYPE="minor"
          # Check for fixes, updates, improvements
          elif echo "$COMMIT_MESSAGES" | grep -iE "(fix:|bug:|patch:|update:|improve:)" > /dev/null; then
            VERSION_TYPE="patch"
          fi
          
          # Override with manual input if workflow_dispatch
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION_TYPE="${{ github.event.inputs.version_type }}"
          fi
          
          echo "Detected version type: $VERSION_TYPE"
          echo "should_version=true" >> $GITHUB_OUTPUT
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT

  update-version:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should_version == 'true'
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      version_tag: ${{ steps.version.outputs.version_tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Calculate new version
        id: version
        run: |
          # Get current version from config.yaml
          CURRENT_VERSION=$(grep '^version:' whorang/config.yaml | sed 's/version: *"\(.*\)"/\1/')
          echo "Current version: $CURRENT_VERSION"
          
          # Remove 'v' prefix if present and split version
          CLEAN_VERSION=${CURRENT_VERSION#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CLEAN_VERSION"
          
          # Increment based on type
          case "${{ needs.detect-changes.outputs.version_type }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          VERSION_TAG="v$NEW_VERSION"
          
          echo "New version: $NEW_VERSION"
          echo "Version tag: $VERSION_TAG"
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "version_tag=$VERSION_TAG" >> $GITHUB_OUTPUT

      - name: Update version in config files
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          
          # Update whorang/config.yaml
          sed -i "s/^version: .*/version: \"$NEW_VERSION\"/" whorang/config.yaml
          
          # Verify the change
          echo "Updated config.yaml:"
          grep "^version:" whorang/config.yaml

      - name: Commit version update
        run: |
          git add whorang/config.yaml
          git commit -m "chore: bump version to ${{ steps.version.outputs.new_version }}"
          git push origin main

  wait-for-build:
    runs-on: ubuntu-latest
    needs: [detect-changes, update-version]
    if: needs.detect-changes.outputs.should_version == 'true'
    steps:
      - name: Wait for build workflow
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const sha = context.sha;
            
            // Wait for the build workflow to start and complete
            let buildWorkflowRun = null;
            let attempts = 0;
            const maxAttempts = 60; // 10 minutes max wait
            
            while (attempts < maxAttempts) {
              const runs = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                status: 'in_progress',
                event: 'push',
                branch: 'main'
              });
              
              // Look for build workflow that started after our commit
              buildWorkflowRun = runs.data.workflow_runs.find(run => 
                run.name === 'Build and Publish Home Assistant Add-on' && 
                run.head_sha === sha
              );
              
              if (buildWorkflowRun) {
                console.log(`Found build workflow: ${buildWorkflowRun.id}`);
                break;
              }
              
              await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds
              attempts++;
            }
            
            if (!buildWorkflowRun) {
              throw new Error('Build workflow not found or did not start');
            }
            
            // Wait for build to complete
            attempts = 0;
            while (attempts < maxAttempts) {
              const run = await github.rest.actions.getWorkflowRun({
                owner,
                repo,
                run_id: buildWorkflowRun.id
              });
              
              if (run.data.status === 'completed') {
                if (run.data.conclusion === 'success') {
                  console.log('Build workflow completed successfully');
                  return;
                } else {
                  throw new Error(`Build workflow failed with conclusion: ${run.data.conclusion}`);
                }
              }
              
              console.log(`Build workflow status: ${run.data.status}`);
              await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds
              attempts++;
            }
            
            throw new Error('Build workflow did not complete within timeout');

  create-tag:
    runs-on: ubuntu-latest
    needs: [detect-changes, update-version, wait-for-build]
    if: needs.detect-changes.outputs.should_version == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push tag
        run: |
          VERSION_TAG="${{ needs.update-version.outputs.version_tag }}"
          NEW_VERSION="${{ needs.update-version.outputs.new_version }}"
          
          # Pull latest changes (including version bump commit)
          git pull origin main
          
          # Create annotated tag
          git tag -a "$VERSION_TAG" -m "Release $VERSION_TAG

          Auto-generated release after successful build.
          
          Changes since last release:
          $(git log $(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo 'HEAD~10')..HEAD --pretty=format:'- %s' | head -20)
          
          Build completed successfully on $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          # Push tag
          git push origin "$VERSION_TAG"
          
          echo "‚úÖ Created and pushed tag: $VERSION_TAG"

      - name: Create GitHub Release
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag = '${{ needs.update-version.outputs.version_tag }}';
            const version = '${{ needs.update-version.outputs.new_version }}';
            
            // Get recent commits for changelog
            const commits = await github.rest.repos.listCommits({
              owner,
              repo,
              sha: 'main',
              per_page: 20
            });
            
            const changelog = commits.data
              .slice(0, 10)
              .map(commit => `- ${commit.commit.message.split('\n')[0]}`)
              .join('\n');
            
            const releaseBody = `## WhoRang AI Doorbell ${tag}

            **Auto-generated release after successful CI/CD pipeline.**

            ### üè† Home Assistant Add-on
            - ‚úÖ Home Assistant 2025.6+ compatible (64-bit only)
            - ‚úÖ Raspberry Pi 4+ support (aarch64)
            - ‚úÖ Intel/AMD 64-bit support
            - ‚úÖ Multi-provider AI analysis
            - ‚úÖ Advanced face recognition
            - ‚úÖ Real-time WebSocket updates

            ### üê≥ Container Images
            - \`ghcr.io/beast12/whorang-addon:${tag}\`
            - \`ghcr.io/beast12/whorang-addon:latest\`

            ### üìã Recent Changes
            ${changelog}

            ### üöÄ Installation
            Add this repository to your Home Assistant add-on store:
            \`https://github.com/Beast12/whorang-addon\`

            ### üìö Documentation
            - [Installation Guide](docs/INSTALLATION.md)
            - [Configuration](docs/CONFIGURATION.md)
            - [API Reference](docs/API_REFERENCE.md)
            `;

            await github.rest.repos.createRelease({
              owner,
              repo,
              tag_name: tag,
              name: `WhoRang AI Doorbell ${tag}`,
              body: releaseBody,
              draft: false,
              prerelease: false
            });
            
            console.log(`‚úÖ Created GitHub release: ${tag}`);
